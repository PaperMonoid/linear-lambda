(define (make-linear-model m b) (vector m b))
(define (linear-model-m-ref model) (vector-ref model 0))
(define (linear-model-b-ref model) (vector-ref model 1))
(define (make-default-linear-model n)
  (make-linear-model (make-vector n 0.0) 0.0))

(define (make-dataset x y) (vector x y))
(define (dataset-x-ref dataset) (vector-ref dataset 0))
(define (dataset-y-ref dataset) (vector-ref dataset 1))

(define (dot x y)
  (define n (vector-length x))
  (define result 0.0)
  (do ((i 0 (+ i 1))) ((>= i n))
    (let ((xi (vector-ref x i)) (yi (vector-ref y i)))
      (set! result (+ result (* xi yi)))))
  result)

(define (vector-sum x)
  (define n (vector-length x))
  (define result 0.0)
  (do ((i 0 (+ i 1))) ((>= i n))
    (let ((xi (vector-ref x i)))
      (set! result (+ result xi))))
  result)

(define (vector-minus x y)
  (define n (vector-length x))
  (define output (make-vector n))
  (do ((i 0 (+ i 1))) ((>= i n))
    (let ((xi (vector-ref x i)) (yi (vector-ref y i)))
      (vector-set! output i (- xi yi))))
  output)

(define (vector-plus x y)
  (define n (vector-length x))
  (define output (make-vector n))
  (do ((i 0 (+ i 1))) ((>= i n))
    (let ((xi (vector-ref x i)) (yi (vector-ref y i)))
      (vector-set! output i (+ xi yi))))
  output)

(define (vector-transpose mat)
  (let* ((rows (vector-length mat))
         (cols (vector-length (vector-ref mat 0)))
         (result (make-vector cols)))
    (do ((j 0 (+ j 1)))
        ((>= j cols) result)
      (let ((col (make-vector rows)))
        (do ((i 0 (+ i 1)))
            ((>= i rows))
          (vector-set! col i (vector-ref (vector-ref mat i) j)))
        (vector-set! result j col)))))

(define (gradient-descent model dataset epochs)
  ;; parameters
  (define gamma 0.95)
  (define l 0.000001)
  ;; data
  (define m (linear-model-m-ref model))
  (define b (linear-model-b-ref model))
  (define x (dataset-x-ref dataset))
  (define y (dataset-y-ref dataset))
  (define n (vector-length x))
  (define xt (vector-transpose x))
  (define pm (make-vector (vector-length xt) 0.0))
  (define pb 0.0)
  (define scale (/ 2.0 n))
  ;; train
  (do ((i 0 (+ i 1))) ((>= i epochs))
    (let* ((y-hat (vector-map (lambda (xn) (+ b (dot xn m))) x))
	   (difference (vector-minus y-hat y))
	   (dm (vector-map (lambda (col) (* scale (dot difference col))) xt))
	   (db (* scale (vector-sum difference))))
      ;; momentum
      (set! pm (vector-plus
		(vector-map (lambda (pm-n) (* gamma pm-n)) pm)
		(vector-map (lambda (dm-n) (* (- 1 gamma) dm-n)) dm)))
      (set! pb (+ (* gamma pb) (* (- 1 gamma) db)))
      ;; learning
      (set! m (vector-minus m (vector-map (lambda (pm-n) (* l pm-n)) pm)))
      (set! b (- b (* l pb)))))
  (make-linear-model m b))

(define (read-all-lines port)
  (let ((lines '()))
    (do ((char (read-char port) (read-char port))
         (line '() (if (or (eof-object? char) (char=? char #\newline))
                       '()
                       (cons char line))))
        ((eof-object? char)
         (if (null? line)
             (reverse lines)
             (reverse (cons (list->string (reverse line)) lines))))
      (when (char=? char #\newline)
          (set! lines (cons (list->string (reverse line)) lines))))))

(define (split-csv-line str)
  (let ((chars (string->list str))
        (fields '())
        (field '()))
    (do ((cs chars (cdr cs)))
        ((null? cs)
         (reverse (cons (list->string (reverse field)) fields)))
      (let ((c (car cs)))
        (if (char=? c #\,)
            (begin
              (set! fields (cons (list->string (reverse field)) fields))
              (set! field '()))
            (set! field (cons c field)))))))

(define (string-list->float-vector lst)
  (list->vector (map string->number lst)))

(define (read-csv path)
  (let ((port (open-input-file path)))
    (let* ((lines (read-all-lines port))
           (rows (map split-csv-line lines))
           (float-rows (map string-list->float-vector rows)))
      (close-input-port port)
      float-rows)))

(define (subvector vec start end)
  (let* ((len (- end start))
         (result (make-vector len)))
    (do ((i 0 (+ i 1)))
        ((>= i len) result)
      (vector-set! result i (vector-ref vec (+ start i))))))

(define (vector-head vec)
  (vector-ref vec 0))

(display "Reading file dataset/MNIST.csv")
(newline)
(define x (vector))
(define y (vector))
(define model (vector))
(let ((data-matrix (list->vector (read-csv "datasets/MNIST.csv"))))
  (display "Done reading!")
  (newline)
  (set! x (vector-map
	   (lambda (xn)
	     (subvector xn 1 (- (vector-length xn) 1)))
	   data-matrix))
  (set! y (vector-map
	   (lambda (xn)
	     (vector-head
	      (subvector xn (- (vector-length xn) 1) (vector-length xn))))
	   data-matrix))
  (set! model (make-default-linear-model (vector-length (vector-ref x 0))))
  (display "Training...")
  (newline)
  (set! model (gradient-descent model (make-dataset x y) 100))
  (display model)
  (newline)
  (let* ((x-sub (subvector x 0 10))
	 (y-sub (subvector y 0 10))
	 (m (linear-model-m-ref model))
	 (b (linear-model-b-ref model))
	 (y-hat (vector-map (lambda (xn) (+ b (dot xn m))) x-sub)))
    (do ((i 0 (+ i 1))) ((>= i 10))
      (display "y-hat: ") (display (vector-ref y-hat i))
      (display " y: ") (display (vector-ref y-sub i))
      (newline))))
